//
// Created by nikitautiu on 10/20/17.
//

#ifndef LAB2_UTILS_H
#define LAB2_UTILS_H


#include <iostream>
#include <functional>
#include <complex>

/*
 * Prints the given matrix in a square layout
 * Expects an iterable of iterables
 */
template <typename T>
void print_matrix(std::vector<std::vector<T>> matrix) {
    for(const auto& line : matrix) {
        for (const auto &elem : line)
            std::cout << elem << ' ';
        std::cout << '\n';
    }
}

template <typename T>
struct matrix_t {
    using type = std::vector<std::vector<T>>;
};

namespace helper {
    /*
    * Returns a random complex number
    */
    template <typename T>
    std::complex<T> rand_complex() {
        return std::complex<T>(std::rand(), std::rand());
    }

    /*
    * Returns a matrix of size n x m filled with
    * random values generated by the passed generator function
    */
    template <typename T>
    std::vector<std::vector<T>> _gen_mat(size_t n, size_t m,
                      std::function<T(void)> generator = []() { return T(); }) {
        auto result = std::vector<std::vector<T>>(n, std::vector<T>(m));
        // fill the created lines with random values
        for(auto& line : result)
            // generate fills the interval with values from the function
            std::generate(std::begin(line), std::end(line), generator);

        return result;
    }


    /*
    * Int matrix generator
    */
    std::vector<std::vector<int>> gen_int_rand_mat(size_t n, size_t m,
                                                   std::function<int(void)> generator=std::rand) {
        return _gen_mat<int>(n, m, generator);
    }

    /*
    * float matrix generator
    */
    std::vector<std::vector<float>> gen_float_rand_mat(size_t n, size_t m) {
        std::function<float(void)> gen  = []() -> float {return (float)std::rand();};
        return _gen_mat<float>(n, m, gen);
    }


    /*
    * Complex number generator
    */
    template <typename T>
    std::vector<std::vector<std::complex<T>>> gen_complex_rand_mat(size_t n, size_t m,
                                                                   std::function<std::complex<T>(void)> generator=rand_complex<T>) {
        return _gen_mat<std::complex<T>>(n, m, generator);
    }

};

template <typename T>
std::vector<std::vector<T>> gen_rand_mat(size_t n, size_t m);

// now the specializations
template <>
std::vector<std::vector<int>>  gen_rand_mat(size_t n, size_t m) {
    return helper::gen_int_rand_mat(n, m);
}

template <>
std::vector<std::vector<float>>  gen_rand_mat(size_t n, size_t m) {
    return helper::gen_float_rand_mat(n, m);
}

template <>
std::vector<std::vector<std::complex<double>>> gen_rand_mat(size_t n, size_t m) {
    return helper::gen_complex_rand_mat<double>(n, m);
}


// bechnmark function
template <typename T>
double benchmark_mat_op(size_t n, size_t m, size_t num_threads,
                      std::function<typename matrix_t<T>::type(const typename matrix_t<T>::type &,
                                                               const typename matrix_t<T>::type &,
                                                               size_t)> bin_op) {
    // generate 2 matrices
    auto mat_a = gen_rand_mat<T>(n, m), mat_b = gen_rand_mat<T>(n, m);

    //time the operation
    auto started = std::chrono::high_resolution_clock::now();
    bin_op(mat_a, mat_b, num_threads);
    auto done = std::chrono::high_resolution_clock::now();

    // return the interval
    return std::chrono::duration_cast<std::chrono::nanoseconds>(done-started).count() / 1000000.;
}


#endif //LAB2_UTILS_H
